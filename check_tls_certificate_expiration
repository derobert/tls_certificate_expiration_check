#!/usr/bin/perl
#
# check_tls_certificate_expiration - Check for nagios/icinga/icinga2 to check TLS Certificates
# Copyright (C) 2015  Josef 'veloc1ty' Stautner (hello@veloc1ty.de)
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.

use strict;
use warnings;
use Getopt::Long;
use Date::Calc qw(Delta_Days Decode_Month Today);
use Crypt::OpenSSL::X509;

# Basic Arguments
our $ARG_WARNING_DAYS = 30;
our $ARG_CRITICAL_DAYS = 10;

# Arguments for network check
our $ARG_ADDRESS = '';
our $ARG_HOSTNAME = ''; # Only used for HTTP SNI
our $ARG_PORT = 443;

# Argument for file check
our $ARG_FILE = '';

main();

sub main {
	parseArguments();
}

sub parseArguments {
	GetOptions (
		'address=s' => \$ARG_ADDRESS,
		'port=s' => \$ARG_HOSTNAME,
		'hostname=s' => \$ARG_HOSTNAME,
		'file=s' => \$ARG_FILE,
		'warn=i' => \$ARG_WARNING_DAYS,
		'crit=i' => \$ARG_CRITICAL_DAYS
	);

	validateArguments();
}

sub validateArguments {
	# Common Arguments
	if ( ! isInteger($ARG_WARNING_DAYS) ) {
		exitUnknown("Argument --warn is not numeric");
	}

	if ( ! isInteger($ARG_CRITICAL_DAYS) ) {
		exitUnknown("Argument --crit is not numeric");
	}

	if ( $ARG_CRITICAL_DAYS > $ARG_WARNING_DAYS ) {
		exitUnknown(sprintf(
			'Critical value (%d) is greater than warning value (%d)',
			$ARG_CRITICAL_DAYS,
			$ARG_WARNING_DAYS
			);
	}

	# Decide which mode
	if ( length ($ARG_FILE) == 0 ) {
		# Network mode
		# Validate network parameter
		validateNetworkArguments();
	}
	else {
		# File mode
		# Validate file parameter
		validateFileArguments();
	}
}

sub validateNetworkArguments {
	if ( length($ARG_ADDRESS) == 0) {
		exitUnknown("Argument --address is not set");
	}

	if ( ! isInteger($ARG_PORT) ) {
		exitUnknown("Argument --port is not numeric");
	}

	if ( $ARG_PORT <= 0 || $ARG_PORT >= 65535 ) {
		exitUnknown("Argument --port is out of bounds! Valid: 1-65535");
	}
}

sub validateFileArguments {
	if ( ! -e $ARG_FILE ) {
		exitUnknown(sprintf(
			"Certificate under %s not found",
			$ARG_FILE
			));
	}
}

sub isInteger {
	my $possibleInteger = shift;

	return 1 if ( $possibleInteger !~ /\d+/ );
	return 0;
}

sub exitUnknown {
	my $errorMessage = shift;
	print("$errorMessage\n");
	exit 3;
}

sub retrieveCertificate {
	my $certificate = '';

	if ( length($ARG_FILE) == 0 ) {
		# Network mode
		# Fetch certificate and return it as a string

	}
	else {
		# File mode
		# Fetch certificate from file and return it as string
		open(CERT, $ARG_FILE);
		my $line = '';

		while ( $line = <CERT> ) {
			$certificate .= $line;
		}

		close(CERT);
	}

	return $certificate;
}

sub decide_exit_code {
	my $daysLeft = shift;

	if ( $daysLeft > $WARNING_DAYS ) {
		print("OK - $daysLeft days left \n");
		exit 0;
	}
	elsif ( $daysLeft > $CRITICAL_DAYS && $daysLeft <= $WARNING_DAYS ) {
		print("WARNING - Certificate is going to expire in $daysLeft days\n");
		exit 1;
	}
	elsif ( $daysLeft <= $CRITICAL_DAYS ) {
		print("CRITICAL - Certificate is going to expire in $daysLeft days\n");
		exit 2;
	}
}

sub calculate_days_left {
	my $expireDate = shift;

	my ($month, $day, $time, $year, $tz) = split(/\s+/, $expireDate);

	my ( $nowYear, $nowMonth, $nowDay) = Today();

	return Delta_Days($nowYear, $nowMonth, $nowDay,
		$year, Decode_Month($month), $day);
}
